## Preprocess your data using XCMS3 and export data files for feature-based molecular networking through GNPS

To follow this example tutorial, download the *MSV000079204* data set from: <br>
https://gnps.ucsd.edu/ProteoSAFe/result.jsp?task=d74ca92d9dec4e2883f28506c670e3ca&view=advanced_view

Note that the settings for *xcms* used in this tutorial were not optimized,
specifically the alignment based on the default *obiwarp* parameters might
perform a little to strong retention time adjustment.
For more information on optimization of the parameters see the [xcms vignette](https://bioconductor.org/packages/release/bioc/vignettes/xcms/inst/doc/xcms.html)
or the [Metabonaut
tutorials](https://rformassspectrometry.github.io/Metabonaut/).

Load required libraries and utility functions for GNPS export.

```{r, message = FALSE}
library(MsExperiment)
library(Spectra)
library(xcms)
source("https://raw.githubusercontent.com/jorainer/xcms-gnps-tools/master/customFunctions.R")
```

Use socket based parallel processing on Windows systems. The number (`4`)
defines the number of parallel tasks. Adapt this setting to the number of CPUs
available on your system. Also note that it is usually better to not use all
CPUs of a system as a) during the analysis the MS data has to be imported from
the original mzML/mzXML/CDF files and it will thus be limited by the I/O of the
hard disks and b) the computer needs to have enough memory to load the complete
MS data of as many raw data files than there are parallel jobs.

```{r}
if (.Platform$OS.type == "unix") {
  register(bpstart(MulticoreParam(4)))
} else {
  register(bpstart(SnowParam(4)))
}
register(SerialParam())
```

### Load data

Load all .mzXML files and define sample grouping. Sample grouping should be
adjusted to the actual experimental setup. For the present example analysis we
put all files into the same sample group.

```{r}
mzxml_files <- dir("MSV000079204", pattern = ".mzXML$",
                   recursive = TRUE, full.names = TRUE)
s_groups <- rep("sample", length(mzxml_files))
pheno <- data.frame(sample_name = basename(mzxml_files), 
                    sample_group = s_groups)
```

```{r}
head(pheno)
```

Read all raw data, including MS2 level.

```{r}
rawData <- readMsExperiment(mzxml_files, sampleData = pheno)
```

Create a base peak chromatogram (BPC) of your data for visual inspection.

```{r, fig.width = 12, fig.height - 6, fig.cap = "Base peak chromatogram"}
bpis <- chromatogram(rawData, aggregationFun = "max")
plot(bpis)
```

### Peak picking

Define settings for the centWave peak detection.

```{r}
cwp <- CentWaveParam(snthresh = 3, noise = 5000,
                     peakwidth = c(5, 30), ppm = 10)
```

Perform the chromatographic peak detection.

```{r, message = FALSE, warning = FALSE}
processedData <- findChromPeaks(rawData, param = cwp)
```

Get an overview of the detected peaks, using a heatmap which represents the
number of peaks detected for each file along the retention time range.

```{r, fig.width = 10, fig.height = 6}
plotChromPeakImage(processedData, binSize = 10) 
```

### Retention time alignment

We skip the retention time adjustment, because the different files have
considerable differences in retention time ranges (ranging from 300 to 5000
seconds).

### Peak grouping

Define the parameters for the *peak density*-based peak grouping (correspondence
analysis).

```{r, message = FALSE, warning = FALSE}
pdp <- PeakDensityParam(sampleGroups = sampleData(processedData)$sample_group,
                        minFraction = 0.10)
processedData <- groupChromPeaks(processedData, param = pdp) 
```

### Gap filling

Fill-in missing peaks. Peak detection might have failed for some features in
some samples. The `fillChromPeaks()` function allows to integrate for such cases
all signal in the respective m/z - retention time range.

```{r, message = FALSE, warning = FALSE}
processedData <- fillChromPeaks(processedData, param = ChromPeakAreaParam())
```

### Export data

#### Export MS1 feature abundances and related MS2 spectra

Below we use the `featureSpectra()` function to extract all MS2 spectra with
their precursor m/z being within the m/z range of a feature/peak and their
retention time within the rt range of the same feature/peak. See the
[XCMS3_Preprocessing.Rmd](XCMS3_Preprocessing.Rmd) file for details and
descriptions of the various functions and parameters used for extracting,
combining and exporting the features' MS2 spectra. 

```{r}
## export the individual spectra into a .mgf file
feature_ms2 <- featureSpectra(processedData, return.type = "Spectra")
feature_ms2 <- filterIntensity(feature_ms2, intensity = 0)
feature_ms2 <- filterEmptySpectra(feature_ms2)
feature_ms2 <- formatSpectraForGNPS(feature_ms2)
```

The extracted MS2 spectra are saved as *ms2spectra_all_bacterial.mgf* file. This
file can for example be used to do *in silico* structure prediction through
[SIRIUS+CSI:FingerID](https://bio.informatik.uni-jena.de/software/sirius/).

```{r}
library(MsBackendMgf)
export(backend = MsBackendMgf(),
       feature_ms2, file = "ms2spectra_all_bacterial.mgf")
```

Export peak area quantification table. To this end we first extract the *feature
definitions* (i.e. the m/z and retention time ranges and other metadata for all
defined features in the data set) and then the integrated peak areas (with the
`featureValues()` function). This peak area quantification table contains
features and respective per sample peak areas in columns. The combined data is
then saved to the file *xcms_all_bacterial.txt*. Note that it is now also
possible to use the entire feature table in the FBMN workflow.

```{r}
## get data
featuresDef <- featureDefinitions(processedData)
featuresIntensities <- featureValues(processedData, value = "into")

## generate data table
dataTable <- merge(featuresDef, featuresIntensities, by=0, all = TRUE)
dataTable <- dataTable[, !(names(dataTable) %in% c("peakidx"))]
colnames(dataTable)[1L] <- "feature_id"
```

```{r}
head(dataTable)
```

```{r}
write.table(dataTable, "xcms_all_bacterial.txt", sep = "\t",
            quote = FALSE, row.names = FALSE)
```

#### Export features with available MS2 spectra only

The `feature_ms2` contains all MS2 spectra with their precursor m/z
within the feature's m/z range and a retention time that is within the retention
time of the chromatographic peak/feature. We thus have multiple MS2 spectra for
each feature (also from each sample). Metadata column `"FEATURE_ID"` indicates
to which feature a MS2 spectrum belongs:

```{r}
head(feature_ms2$FEATURE_ID)
```

We next select a single MS2 spectrum for each feature and export this reduced
set also as an .mgf file. In this first example we report the fragment peaks of
the MS2 spectrum with the highest TIC (sum of fragment intensities). See the
[XCMS3_Preprocessing.Rmd](XCMS3_Preprocessing.Rmd) file for more information and
description of the settings.

```{r}
## Select for each feature the Spectrum2 with the largest TIC.
feature_ms2_maxtic <- combineSpectra(
    feature_ms2, f = feature_ms2$FEATURE_ID,
    p = rep(1, length(feature_ms2)), FUN = maxTicPeaksData)
spectraNames(feature_ms2_maxtic) <- paste0(
    feature_ms2_maxtic$FEATURE_ID, " maxTic")
```

Next we export the data to a file which can then be submitted to GNPS [feature-based
molecular
networking](https://ccms-ucsd.github.io/GNPSDocumentation/featurebasedmolecularnetworking/).

```{r}
export(backend = MsBackendMgf(),
       feature_ms2_maxtic, file = "ms2spectra_maxTic_bacterial.mgf")
```

At last we subset the peak area quantification table to features for which we
have also an MS2 spectrum and export this to the *xcms_onlyMS2_bacterial.txt*
file. This file can be submitted to GNPS [feature-based molecular
networking](https://ccms-ucsd.github.io/GNPSDocumentation/featurebasedmolecularnetworking/):

```{r}
## filter data table to contain only peaks with MSMS DF[ , !(names(DF) %in% drops)]
filteredDataTable <- dataTable[which(
    dataTable$feature_id %in% feature_ms2_maxtic$FEATURE_ID),]
```

```{r}
head(filteredDataTable)
```

```{r}
write.table(filteredDataTable, "xcms_onlyMS2_bacterial.txt",
            sep = "\t", quote = FALSE, row.names = FALSE)
```

#### Export MS2 consensus spectra

Alternatively, instead of selecting the spectrum with the largest total signal
as representative MS2 spectrum for each feature, we can create a *consensus MS2
spectrum*. A consensus MS2 spectrum can for example be created by combining all
MS2 spectra for a feature into a single spectrum that contains peaks present in
the majority of spectra. Note however that this feature is experimental at
present. Again, see the [XCMS3_Preprocessing.Rmd](XCMS3_Preprocessing.Rmd) file
for more information.

```{r, message = FALSE, warning = FALSE}
feature_ms2_consensus <- combineSpectra(
    feature_ms2, f = feature_ms2$FEATURE_ID, p = rep(1, length(feature_ms2)),
    ppm = 10, peaks = "intersect", minProp = 0.5)
spectraNames(feature_ms2_consensus) <- paste0(
    feature_ms2_maxtic$FEATURE_ID, " consensus")
#' get rid of empty spectra
feature_ms2_consensus <- filterEmptySpectra(feature_ms2_consensus)

export(backend = MsBackendMgf(),
       feature_ms2_consensus, file = "ms2spectra_consensus_bacterial.mgf")
```

Analogously we subset the peak area quantification table to features for which
we have an MS2 consensus spectrum and export this to the
*xcms_consensusMS2_bacterial.txt* file. This file can be submitted to GNPS
[feature-based molecular
networking](https://ccms-ucsd.github.io/GNPSDocumentation/featurebasedmolecularnetworking/):

```{r}
consensusDataTable <- dataTable[which(dataTable$feature_id %in%
                                      feature_ms2_consensus$FEATURE_ID),]
head(consensusDataTable)
write.table(consensusDataTable, "xcms_consensusMS2_bacterial.txt",
            sep = "\t", quote = FALSE, row.names = FALSE)
```

### Session information

```{r}
sessionInfo()
```
